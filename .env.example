# =============================================================================
# MCP Gateway Registry - Environment Configuration Sample
# =============================================================================
# Copy this file to .env and update with your actual values
# Never commit real credentials to version control

# =============================================================================
# REGISTRY CONFIGURATION
# =============================================================================

# Public URL where the MCP Gateway Registry is accessible
# For custom HTTPS domain: https://mcpgateway.mycorp.com
REGISTRY_URL=http://localhost

# Registry admin credentials
ADMIN_USER=admin
# Generate with: openssl rand -base64 24 | tr -d '/+=' | head -c 32
ADMIN_PASSWORD=your-secure-password-here

# =============================================================================
# AUTH SERVER CONFIGURATION
# =============================================================================

# Internal auth server URL (for Docker network communication)
AUTH_SERVER_URL=http://auth-server:8888

# External auth server URL (public-facing, for browser redirects)
# For local development: http://localhost:8888
# For custom HTTPS domain: https://mcpgateway.mycorp.com
AUTH_SERVER_EXTERNAL_URL=http://localhost:8888

# =============================================================================
# AUTHENTICATION PROVIDER CONFIGURATION
# =============================================================================
# Choose authentication provider: 'cognito', 'keycloak', or 'entra'
AUTH_PROVIDER=keycloak

# =============================================================================
# KEYCLOAK CONFIGURATION (if AUTH_PROVIDER=keycloak)
# =============================================================================

# Keycloak server URL (internal URL for server-to-server communication)
# DO NOT CHANGE: This should always be http://keycloak:8080 for Docker network communication
KEYCLOAK_URL=http://keycloak:8080

# Keycloak external URL (for browser redirects)
# For local development: http://localhost:8080
# For custom HTTPS domain: https://mcpgateway.mycorp.com
KEYCLOAK_EXTERNAL_URL=http://localhost:8080

# Keycloak admin URL (for setup scripts - internal access)
# Typically http://localhost:8080 for local access to Keycloak admin
# For custom HTTPS domain: https://mcpgateway.mycorp.com
KEYCLOAK_ADMIN_URL=http://localhost:8080

# Keycloak realm name
KEYCLOAK_REALM=mcp-gateway

# Keycloak admin credentials (for initial setup)
KEYCLOAK_ADMIN=admin
# Generate with: openssl rand -base64 24 | tr -d '/+=' | head -c 32
KEYCLOAK_ADMIN_PASSWORD=your-secure-keycloak-admin-password

# Keycloak database password
# Generate with: openssl rand -base64 24 | tr -d '/+=' | head -c 32
KEYCLOAK_DB_PASSWORD=your-secure-db-password

# Keycloak client credentials for web authentication
# These are auto-generated when you run keycloak/setup/init-keycloak.sh
# To retrieve: Check script output or Keycloak Admin Console → Clients → Credentials tab
KEYCLOAK_CLIENT_ID=mcp-gateway-web
# Generate with: openssl rand -base64 32 | tr -d '/+=' | head -c 32
KEYCLOAK_CLIENT_SECRET=your-keycloak-client-secret-here

# Keycloak M2M client credentials for machine-to-machine authentication
# These are auto-generated when you run keycloak/setup/init-keycloak.sh
# To retrieve: Check script output or Keycloak Admin Console → Clients → Credentials tab
KEYCLOAK_M2M_CLIENT_ID=mcp-gateway-m2m
# Generate with: openssl rand -base64 32 | tr -d '/+=' | head -c 32
KEYCLOAK_M2M_CLIENT_SECRET=your-keycloak-m2m-secret-here

# Enable Keycloak in OAuth2 providers
KEYCLOAK_ENABLED=true

# MCP Gateway Application User Passwords (mcp-gateway realm)
# These are for logging into the MCP Gateway web application at http://localhost
# NOT for the Keycloak Admin Console (use KEYCLOAK_ADMIN_PASSWORD for that)
#
# Default users created by init-keycloak.sh:
#   - admin (uses INITIAL_ADMIN_PASSWORD, default: changeme)
#   - testuser (uses INITIAL_USER_PASSWORD, default: testpass)
#
# Generate with: openssl rand -base64 24 | tr -d '/+=' | head -c 32
INITIAL_ADMIN_PASSWORD=changeme
# Generate with: openssl rand -base64 24 | tr -d '/+=' | head -c 32
INITIAL_USER_PASSWORD=testpass

# =============================================================================
# GATEWAY HOST CONFIGURATION
# =============================================================================

# Optional: Additional server names for nginx reverse proxy gateway access
# Use this to add custom domain names, public IPs, or private IPs to the nginx server_name directive
# Supports multiple names separated by spaces
#
# Examples:
#   - Custom domain: mcpgateway.example.com
#   - Public IP: 54.123.45.67
#   - Private IP: 10.0.1.42
#   - Multiple: mcpgateway.example.com 54.123.45.67
#
# Default: Empty (will auto-detect private IP if available)
# WARNING: HTTP access is not recommended for production. Use HTTPS with valid SSL certificates.
# GATEWAY_ADDITIONAL_SERVER_NAMES=

# =============================================================================
# AMAZON COGNITO OAUTH2 CONFIGURATION (if AUTH_PROVIDER=cognito)
# =============================================================================

# AWS Configuration
AWS_REGION=us-east-1

# Amazon Cognito User Pool ID
# Format: {region}_{random_string}
# Generate with 'openssl rand -base64 7 | tr -d '/+=' | head -c 32'
COGNITO_USER_POOL_ID=us-east-1_XXXXXXXXX

# Cognito App Client ID
# Get this from Amazon Cognito console > User Pools > App Integration > App clients
COGNITO_CLIENT_ID=your_cognito_client_id_here

# Cognito App Client Secret
# Get this from Amazon Cognito console > User Pools > App Integration > App clients
COGNITO_CLIENT_SECRET=your_cognito_client_secret_here

# Enable Cognito in OAuth2 providers
COGNITO_ENABLED=false

# =============================================================================
# MICROSOFT ENTRA ID CONFIGURATION (if AUTH_PROVIDER=entra)
# =============================================================================

# Azure AD Tenant ID (Directory/tenant ID from Azure Portal)
# Format: GUID (e.g., 12345678-1234-1234-1234-123456789012)
# Get from: Azure Portal → Azure Active Directory → Overview → Tenant ID
ENTRA_TENANT_ID=your-tenant-id-here

# Entra ID Application (client) ID
# Format: GUID (e.g., 87654321-4321-4321-4321-210987654321)
# Get from: Azure Portal → App registrations → Your App → Application (client) ID
ENTRA_CLIENT_ID=your-client-id-here

# Entra ID Client Secret (Application secret value)
# Get from: Azure Portal → App registrations → Your App → Certificates & secrets
# NOTE: Copy the secret VALUE immediately after creation (not the secret ID)
ENTRA_CLIENT_SECRET=your-client-secret-here

# Enable Entra ID in OAuth2 providers (set to true when using Entra ID)
ENTRA_ENABLED=false

# Entra ID Login Base URL (optional - defaults to https://login.microsoftonline.com)
# Change this only if using a sovereign cloud (e.g., Azure Government, Azure China)
# Examples:
#   - Azure Public Cloud (default): https://login.microsoftonline.com
#   - Azure Government: https://login.microsoftonline.us
#   - Azure China: https://login.chinacloudapi.cn
#   - Azure Germany: https://login.microsoftonline.de
# ENTRA_LOGIN_BASE_URL=https://login.microsoftonline.com

# Azure AD Group Object IDs for authorization (configured in scopes.yml)
# Admin Group Example
ENTRA_GROUP_ADMIN_ID=your-admin-group-object-id-here
# Users Group Example
ENTRA_GROUP_USERS_ID=your-users-group-object-id-here

# =============================================================================
# GITHUB OAUTH2 CONFIGURATION
# =============================================================================

# GitHub OAuth App Client ID
# Get this from GitHub > Settings > Developer settings > OAuth Apps
GITHUB_CLIENT_ID=your_github_client_id_here

# GitHub OAuth App Client Secret
GITHUB_CLIENT_SECRET=your_github_client_secret_here

# Enable GitHub in OAuth2 providers
GITHUB_ENABLED=false

# =============================================================================
# GOOGLE OAUTH2 CONFIGURATION
# =============================================================================

# Google OAuth2 Client ID
# Get this from Google Cloud Console > APIs & Services > Credentials
GOOGLE_CLIENT_ID=your_google_client_id_here

# Google OAuth2 Client Secret
GOOGLE_CLIENT_SECRET=your_google_client_secret_here

# Enable Google in OAuth2 providers
GOOGLE_ENABLED=false

# =============================================================================
# APPLICATION SECURITY
# =============================================================================

# CRITICAL: CHANGE THIS SECRET KEY IMMEDIATELY!
# This is used for JWT token signing and session security
# Generate a strong, random 64-character string in production
# WARNING: Using the default value is a security risk!
# Generate with: python3 -c "import secrets; print(secrets.token_hex(32))"
SECRET_KEY=CHANGE-THIS-IMMEDIATELY-use-a-strong-random-key-in-production

# =============================================================================
# SESSION COOKIE CONFIGURATION
# =============================================================================

# Session cookie secure flag (HTTPS-only transmission)
# IMPORTANT: Set based on your environment:
#   - Local development (localhost via HTTP): Set to false
#   - Production with HTTPS: Set to true
#
# If set to true, cookies will ONLY be sent over HTTPS connections.
# Setting this to true on localhost (HTTP) will cause login to fail!
#
# Default: false (safe for local development)
# Production: MUST be true
SESSION_COOKIE_SECURE=false

# Session cookie domain (for cross-subdomain authentication)
# Leave unset or empty for single-domain deployments (RECOMMENDED for most cases)
# Set to domain with leading dot for cross-subdomain sharing
#
# Examples:
#   Single domain (mcpgateway.ddns.net): Leave unset or set to empty string
#     SESSION_COOKIE_DOMAIN=
#
#   Cross-subdomain (auth.example.com + registry.example.com): Set to .example.com
#     SESSION_COOKIE_DOMAIN=.example.com
#
#   Multi-level domains (registry.region-1.corp.company.internal): Set to your org domain
#     SESSION_COOKIE_DOMAIN=.corp.company.internal
#
# Default: Empty (cookie scoped to exact host only - safest option)
SESSION_COOKIE_DOMAIN=

# =============================================================================
# AI/LLM CONFIGURATION
# =============================================================================

# Anthropic API Key for Claude models (required for agent functionality)
# Get this from https://console.anthropic.com/
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Smithery API Key for accessing Smithery-hosted MCP servers
# Get this from https://smithery.ai/
SMITHERY_API_KEY=your_smithery_api_key_here

# =============================================================================
# SECURITY SCANNING CONFIGURATION (Cisco AI Defense Integration)
# =============================================================================

# Enable/disable security scanning for MCP servers
# When enabled, servers are scanned during registration for security threats
SECURITY_SCAN_ENABLED=true

# Automatically scan servers when they are registered
# Set to false to disable automatic scanning on registration
SECURITY_SCAN_ON_REGISTRATION=true

# Block (disable) servers that fail security scans
# When true, unsafe servers are automatically disabled
# When false, unsafe servers remain enabled but tagged
SECURITY_BLOCK_UNSAFE_SERVERS=true

# Analyzers to use for security scanning (comma-separated)
# Available: yara, llm, api
# - yara: Pattern matching with YARA rules (no API key required)
# - llm: LLM-as-a-judge evaluation (requires MCP_SCANNER_LLM_API_KEY)
# - api: Cisco AI Defense inspect API (requires Cisco credentials)
SECURITY_ANALYZERS=yara

# Security scan timeout in seconds (default: 300 = 5 minutes)
SECURITY_SCAN_TIMEOUT=60

# Add 'security-pending' tag to servers that fail security scan
# This helps identify servers awaiting security review
SECURITY_ADD_PENDING_TAG=true

# MCP Security Scanner LLM API Key (optional - only needed for LLM-based security analysis)
# Default analyzer is YARA (no API key required)
# To use LLM analyzer, set SECURITY_ANALYZERS=yara,llm and use:
#   uv run python api/registry_management.py register --config config.json
# Get OpenAI API key from https://platform.openai.com/api-keys
MCP_SCANNER_LLM_API_KEY=your_openai_api_key_here

# MCP Security Scanner LLM Model (optional - defaults to openai/gpt-4o-mini)
# Supports any LiteLLM-compatible model including AWS Bedrock:
#   - openai/gpt-4o-mini (default)
#   - bedrock/anthropic.claude-sonnet-4-5-20250929-v2:0 (AWS Bedrock)
#   - azure/gpt-4 (Azure OpenAI)
# MCP_SCANNER_LLM_MODEL=openai/gpt-4o-mini

# MCP Security Scanner Base URL (optional - for LiteLLM proxy or custom endpoints)
# For Azure OpenAI: https://your-resource.openai.azure.com/
# For custom LLM proxy: https://your-litellm-proxy.example.com
# MCP_SCANNER_LLM_BASE_URL=https://api.openai.com/v1

# MCP Security Scanner API Version (optional - required for some providers)
# For Azure OpenAI: 2024-02-01
# MCP_SCANNER_LLM_API_VERSION=2024-02-01

# MCP Security Scanner LLM Timeout (optional - increase for extended thinking models)
# Default: 60 seconds, increase for complex analysis or slow models
# MCP_SCANNER_LLM_TIMEOUT=300

# =============================================================================
# GLOBAL LLM CONFIGURATION (defaults for all LLM operations)
# =============================================================================
# These settings provide fallback values for embeddings and scanners.
# Component-specific settings (e.g., EMBEDDINGS_API_KEY) take precedence.

# LLM provider: 'litellm' for LiteLLM proxy or direct provider access
LLM_PROVIDER=litellm

# Default LLM model for operations that require chat/completion
LLM_MODEL=openai/gpt-4o-mini

# Global API key (used as fallback if component-specific key not set)
# LLM_API_KEY=your_api_key_here

# Global API base URL (used as fallback for LiteLLM proxy)
# Set this to use a centralized LiteLLM proxy for all LLM operations
# LLM_API_BASE=https://your-litellm-proxy.example.com

# =============================================================================
# EMBEDDINGS CONFIGURATION
# =============================================================================

# Embeddings provider: 'sentence-transformers' (local) or 'litellm' (cloud-based)
# Default: sentence-transformers (no API key required)
EMBEDDINGS_PROVIDER=litellm

# Model name for embeddings generation
# For sentence-transformers: model name from Hugging Face (e.g., all-MiniLM-L6-v2)
# For litellm (direct): provider-prefixed model required (e.g., bedrock/amazon.titan-embed-text-v1,
#                       openai/text-embedding-3-small, cohere/embed-english-v3.0)
# For litellm (with proxy): prefix optional - both 'text-embedding-3-small' and
#                           'openai/text-embedding-3-small' are accepted when EMBEDDINGS_API_BASE is set
EMBEDDINGS_MODEL_NAME=bedrock/amazon.titan-embed-text-v2:0

# Embedding dimension (must match the model's output dimension)
# all-MiniLM-L6-v2: 384
# text-embedding-3-small: 1536
# text-embedding-3-large: 3072
# amazon.titan-embed-text-v1: 1536
# cohere/embed-english-v3.0: 1024
EMBEDDINGS_MODEL_DIMENSIONS=1024

# LiteLLM-specific settings (only used when EMBEDDINGS_PROVIDER=litellm)
# API key for cloud embeddings provider (provider-specific)
# For OpenAI: Get from https://platform.openai.com/api-keys
# For Cohere: Get from https://dashboard.cohere.com/api-keys
# For Bedrock: Not used - configure AWS credentials via standard methods (see below)
# EMBEDDINGS_API_KEY=your_api_key_here

# Optional: Custom API base URL for LiteLLM proxy or OpenAI-compatible endpoint
# When set, model name prefix (e.g., 'openai/') becomes optional as proxy handles routing
# EMBEDDINGS_API_BASE=https://your-litellm-proxy.com

# AWS region for Amazon Bedrock embeddings (only needed for Bedrock)
# Note: For Bedrock authentication, use standard AWS credential chain:
#       - IAM roles (recommended for EC2/EKS)
#       - Environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)
#       - AWS credentials file (~/.aws/credentials)
# EMBEDDINGS_AWS_REGION=us-east-1

# =============================================================================
# A2A AGENT SECURITY SCANNING CONFIGURATION
# =============================================================================

# Enable/disable security scanning for A2A agents
# When enabled, agents are scanned during registration for security threats
AGENT_SECURITY_SCAN_ENABLED=true

# Automatically scan agents when they are registered
# Set to false to disable automatic scanning on registration
AGENT_SECURITY_SCAN_ON_REGISTRATION=true

# Block (disable) agents that fail security scans
# When true, unsafe agents are automatically disabled
# When false, unsafe agents remain enabled but tagged
AGENT_SECURITY_BLOCK_UNSAFE_AGENTS=true

# Analyzers to use for agent security scanning (comma-separated)
# Available: yara, spec, heuristic, llm, endpoint
# - yara: Pattern matching with YARA rules (no API key required)
# - spec: A2A protocol specification validation (no API key required)
# - heuristic: Logic-based threat detection (no API key required)
# - llm: LLM-as-a-judge evaluation (requires A2A_SCANNER_LLM_API_KEY)
# - endpoint: Dynamic endpoint security testing (requires live agent)
AGENT_SECURITY_ANALYZERS=yara,spec

# Agent security scan timeout in seconds (default: 60 = 1 minute)
AGENT_SECURITY_SCAN_TIMEOUT=60

# Add 'security-pending' tag to agents that fail security scan
# This helps identify agents awaiting security review
AGENT_SECURITY_ADD_PENDING_TAG=true

# A2A Security Scanner LLM API Key (optional - only needed for LLM-based agent analysis)
# Default analyzers are YARA and Spec (no API key required)
# Get Azure OpenAI API key from https://portal.azure.com/
A2A_SCANNER_LLM_API_KEY=your_azure_openai_api_key_here

# A2A Security Scanner LLM Model (optional - defaults to openai/gpt-4o-mini)
# A2A_SCANNER_LLM_MODEL=openai/gpt-4o-mini

# A2A Security Scanner API Base URL (optional - for LiteLLM proxy)
# A2A_SCANNER_LLM_API_BASE=https://your-litellm-proxy.example.com

# =============================================================================
# CONTAINER REGISTRY CREDENTIALS (for CI/CD and local builds)
# =============================================================================

# Docker Hub credentials for publishing container images
# Get these from https://hub.docker.com/settings/security
DOCKERHUB_USERNAME=your_dockerhub_username
DOCKERHUB_TOKEN=your_dockerhub_access_token

# GitHub Container Registry credentials (optional - for publishing to ghcr.io)
# The GITHUB_TOKEN is automatically provided in GitHub Actions
# For local builds, generate a Personal Access Token with packages:write scope
# Get this from https://github.com/settings/tokens
# GITHUB_USERNAME=your_github_username
# GITHUB_TOKEN=your_github_personal_access_token

# Container registry configuration for PULLING pre-built images
# IMAGE_REGISTRY specifies the base registry URL for pre-built images
# Used by docker-compose.prebuilt.yml when running the stack
# Default: ghcr.io/jrmatherly (GitHub Container Registry)
# IMAGE_REGISTRY=ghcr.io/jrmatherly

# Container registry configuration for PUBLISHING images (developer use only)
# Used by scripts/publish_containers.sh when building and pushing new releases
# DOCKERHUB_ORG: Docker Hub organization (optional, falls back to DOCKERHUB_USERNAME)
# GITHUB_ORG: GitHub org/user for ghcr.io (auto-detected from git remote if not set)
# DOCKERHUB_ORG=mcpgateway
# GITHUB_ORG=jrmatherly

# =============================================================================
# EXTERNAL REGISTRY CONFIGURATION
# =============================================================================

# Comma-separated list of tags that identify external registry servers
# These tags are used by the frontend to separate internal MCP servers from
# external registry integrations (e.g., Anthropic, Workday, etc.)
# Servers tagged with these values will appear in the "External Registries" tab
# Default: anthropic-registry,workday-asor
EXTERNAL_REGISTRY_TAGS=anthropic-registry,workday-asor

# =============================================================================
# FEDERATION CONFIGURATION (ASOR/Workday Integration)
# =============================================================================
# Federation allows importing agents from external agent registries like Workday ASOR.
# See docs/federation.md for complete setup instructions.

# ASOR (Agent Service for Orchestration and Routing) Integration
# ASOR uses OAuth2 3-legged authentication. To obtain an access token:
# 1. Run: python get_asor_token.py
# 2. Complete the browser OAuth flow
# 3. The token will be saved here automatically
# ASOR_ACCESS_TOKEN=<generated by get_asor_token.py>

# Alternative: ASOR Client Credentials (for 2-legged OAuth, if supported)
# Format: client_id:client_secret
# ASOR_CLIENT_CREDENTIALS=your_client_id:your_client_secret

# =============================================================================
# STORAGE BACKEND CONFIGURATION
# =============================================================================

# Storage Backend Selection
# Options:
#   "file" - Uses JSON files (simple, local development)
#   "documentdb" - Uses Amazon DocumentDB (production, no native vector search)
#   "mongodb-ce" - Uses MongoDB Community Edition 8.2 (local dev, application-level vector search)
#   "mongodb" - Uses MongoDB CE 8.2+ with native $vectorSearch (recommended for K8s deployments)
# For production Kubernetes deployments, "mongodb" is recommended for native vector search
# For local development, "mongodb-ce" is recommended
# Options: file, mongodb-ce, mongodb, documentdb
STORAGE_BACKEND=mongodb-ce

# DocumentDB Configuration (used when STORAGE_BACKEND=documentdb or mongodb-ce)
# Amazon DocumentDB (MongoDB-compatible) or MongoDB connection settings

# For local MongoDB CE (mongodb-ce backend):
# Authentication with SCRAM-SHA-256 (stronger than SCRAM-SHA-1)
DOCUMENTDB_HOST=mongodb
DOCUMENTDB_PORT=27017
DOCUMENTDB_DATABASE=mcp_registry
DOCUMENTDB_USERNAME=admin
# Default: admin (for local dev). For production, generate with: openssl rand -base64 24 | tr -d '/+=' | head -c 32
DOCUMENTDB_PASSWORD=admin
DOCUMENTDB_USE_TLS=false
DOCUMENTDB_NAMESPACE=default

# For AWS DocumentDB (documentdb backend):
# Uses SCRAM-SHA-1 (AWS DocumentDB v5.0 limitation)
# DOCUMENTDB_HOST=your-documentdb-cluster.cluster-xxxxx.us-east-1.docdb.amazonaws.com
# DOCUMENTDB_PORT=27017
# DOCUMENTDB_DATABASE=mcp_registry
# DOCUMENTDB_USERNAME=your_username
# DOCUMENTDB_PASSWORD=your_password
# DOCUMENTDB_USE_TLS=true
# DOCUMENTDB_TLS_CA_FILE=global-bundle.pem
# DOCUMENTDB_USE_IAM=false
# DOCUMENTDB_REPLICA_SET=rs0
# DOCUMENTDB_READ_PREFERENCE=secondaryPreferred
# DOCUMENTDB_NAMESPACE=default

# =============================================================================
# MONGODB CE 8.2+ NATIVE VECTOR SEARCH CONFIGURATION
# =============================================================================
# These settings are used when STORAGE_BACKEND=mongodb (Kubernetes with MongoDB Operator)
# Native $vectorSearch requires MongoDB CE 8.2+ with mongot pods deployed via MongoDBSearch CRD
#
# Enable native MongoDB $vectorSearch aggregation stage
# When true, uses MongoDB's native vector search via mongot
# When false, falls back to application-level similarity calculations
MONGODB_CE_82_NATIVE_SEARCH=true

# Vector search index name (must match index created in MongoDB)
MONGODB_VECTOR_INDEX_NAME=vector_index

# Similarity metric for vector comparisons
# Options: cosine, euclidean, dotProduct
MONGODB_VECTOR_SIMILARITY_METRIC=cosine

# Number of candidates multiplier for vector search
# Higher values increase accuracy but decrease performance
# numCandidates = limit * multiplier
MONGODB_VECTOR_NUM_CANDIDATES_MULTIPLIER=10

# =============================================================================
# ADDITIONAL CONFIGURATION
# =============================================================================

# Optional: Set specific Cognito domain if using custom domain
# COGNITO_DOMAIN=your-custom-domain.auth.{region}.amazoncognito.com

# Optional: Additional service-specific environment variables
# Add any additional configuration variables your deployment requires

# =============================================================================
# METRICS SERVICE CONFIGURATION
# =============================================================================
# The metrics service collects telemetry from all MCP Gateway components.
# API keys are used to authenticate metrics submissions from each service.
# See docs/metrics-architecture.md for complete documentation.

# NOTE: These API keys are AUTO-GENERATED by build_and_run.sh if not present.
# You only need to set them manually if you want specific values or are not
# using build_and_run.sh for deployment.

# Metrics API keys for each service (auto-generated if not set)
# Format: mcp_metrics_<random_hex>
#
# To generate manually, run each command and set the corresponding variable:
#   METRICS_API_KEY_AUTH_SERVER: openssl rand -hex 16 | sed 's/^/mcp_metrics_/'
#   METRICS_API_KEY_REGISTRY:    openssl rand -hex 16 | sed 's/^/mcp_metrics_/'
#   METRICS_API_KEY_MCPGW_SERVER: openssl rand -hex 16 | sed 's/^/mcp_metrics_/'
#
# METRICS_API_KEY_AUTH_SERVER=mcp_metrics_<your_generated_hex>
# METRICS_API_KEY_REGISTRY=mcp_metrics_<your_generated_hex>
# METRICS_API_KEY_MCPGW_SERVER=mcp_metrics_<your_generated_hex>

# =============================================================================
# AUTO-MANAGED VARIABLES (Do Not Edit)
# =============================================================================
# The following variables are automatically managed by system scripts.
# DO NOT set these manually - they will be overwritten by automated processes.

# OAuth tokens populated by credentials-provider OAuth flows:
# ATLASSIAN_AUTH_TOKEN=<auto-populated by credentials-provider OAuth flow>
# SRE_GATEWAY_AUTH_TOKEN=<auto-populated by credentials-provider OAuth flow>

# Metrics API keys (auto-generated by build_and_run.sh if not present):
# METRICS_API_KEY_AUTH_SERVER=<auto-generated>
# METRICS_API_KEY_REGISTRY=<auto-generated>
# METRICS_API_KEY_MCPGW_SERVER=<auto-generated>

# Common Vulnerability Patterns

## Dependency Vulnerabilities

### High Severity Patterns

#### Remote Code Execution (RCE)
```
# Indicators in pip-audit output
CVE severity: HIGH or CRITICAL
Keywords: "arbitrary code", "remote execution", "deserialization"

# Common affected packages
- PyYAML (unsafe load)
- Pillow (image processing)
- lxml (XML parsing)
- Jinja2 (template injection)
```

#### SQL/NoSQL Injection
```python
# Bad - string interpolation in queries
query = f"SELECT * FROM users WHERE id = '{user_id}'"
collection.find({"$where": f"this.name == '{input}'"})

# Good - parameterized queries
query = "SELECT * FROM users WHERE id = %s"
collection.find({"name": input})
```

#### Authentication Bypass
```
# Indicators
CVE keywords: "authentication bypass", "authorization", "privilege escalation"

# Commonly affected packages
- python-jose, PyJWT (JWT vulnerabilities)
- authlib, oauthlib (OAuth issues)
- cryptography (weak algorithms)
```

### Medium Severity Patterns

#### Denial of Service (DoS)
```
# Indicators
CVE keywords: "denial of service", "resource exhaustion", "infinite loop"

# Common causes
- ReDoS (regex denial of service)
- XML bomb / billion laughs
- Unbounded memory allocation
```

#### Information Disclosure
```
# Indicators
CVE keywords: "information disclosure", "sensitive data exposure", "path traversal"

# Check for
- Error messages revealing stack traces
- Debug endpoints exposed
- Verbose logging of sensitive data
```

### Low Severity Patterns

#### Timing Attacks
```python
# Bad - non-constant time comparison
if user_token == stored_token:
    grant_access()

# Good - constant time comparison
import hmac
if hmac.compare_digest(user_token, stored_token):
    grant_access()
```

## Code Vulnerabilities (Bandit)

### B101: assert_used
```python
# Bad - assertions stripped in optimized bytecode
assert user.is_admin, "Must be admin"

# Good - explicit check
if not user.is_admin:
    raise PermissionError("Must be admin")
```

### B102: exec_used
```python
# Bad - arbitrary code execution
exec(user_provided_code)

# Good - use safer alternatives
# If dynamic execution needed, use restricted environments
```

### B103: set_bad_file_permissions
```python
# Bad - world-writable file
os.chmod(path, 0o777)

# Good - restrictive permissions
os.chmod(path, 0o600)  # Owner read/write only
```

### B104: hardcoded_bind_all_interfaces
```python
# Bad - binds to all interfaces
app.run(host="0.0.0.0", port=8000)

# Good - bind to specific interface
app.run(host="127.0.0.1", port=8000)
```

### B105-B107: hardcoded_password/tmp
```python
# Bad - hardcoded credentials
password = "secret123"
API_KEY = "sk-abc123..."

# Good - from environment
password = os.environ.get("DB_PASSWORD")
API_KEY = os.environ.get("API_KEY")
```

### B108: hardcoded_tmp_directory
```python
# Bad - predictable temp location
with open("/tmp/myapp.log", "w") as f:
    f.write(data)

# Good - secure temp file
import tempfile
with tempfile.NamedTemporaryFile(delete=False) as f:
    f.write(data)
```

### B110: try_except_pass
```python
# Bad - silently ignores exceptions
try:
    risky_operation()
except:
    pass

# Good - log or handle appropriately
try:
    risky_operation()
except SpecificException as e:
    logger.error(f"Operation failed: {e}")
```

### B311: random
```python
# Bad - predictable random for security purposes
import random
token = random.randint(0, 999999)

# Good - cryptographically secure random
import secrets
token = secrets.token_urlsafe(32)
```

### B320: xml_bad_tree
```python
# Bad - vulnerable to XXE attacks
from xml.etree import ElementTree
tree = ElementTree.parse(untrusted_xml)

# Good - use defusedxml
import defusedxml.ElementTree as ET
tree = ET.parse(untrusted_xml)
```

### B324: hashlib_insecure
```python
# Bad - weak hash algorithms
import hashlib
hash = hashlib.md5(data).hexdigest()
hash = hashlib.sha1(data).hexdigest()

# Good - use strong algorithms
hash = hashlib.sha256(data).hexdigest()
hash = hashlib.sha3_256(data).hexdigest()
```

### B501-B503: request_with_no_cert_validation
```python
# Bad - disables certificate verification
requests.get(url, verify=False)

# Good - verify certificates
requests.get(url, verify=True)  # or specify CA bundle
requests.get(url, verify="/path/to/ca-bundle.crt")
```

## OWASP Top 10 Patterns

### A01: Broken Access Control
```python
# Check for
- Missing authorization checks on endpoints
- IDOR (Insecure Direct Object Reference)
- Missing function-level access control

# Pattern to look for
@router.get("/users/{user_id}")
async def get_user(user_id: str):
    # Missing: check if current_user can access user_id
    return await repo.get(user_id)
```

### A02: Cryptographic Failures
```python
# Check for
- Weak encryption algorithms (DES, RC4)
- Hardcoded encryption keys
- Missing encryption for sensitive data at rest
- HTTP instead of HTTPS
```

### A03: Injection
```python
# Check for
- String concatenation in queries
- Unsafe template rendering
- Command injection via subprocess
- LDAP injection
- XPath injection
```

### A05: Security Misconfiguration
```python
# Check for
- Debug mode enabled in production
- Default credentials
- Unnecessary features enabled
- Missing security headers
- Verbose error messages
```

### A07: Identification and Authentication Failures
```python
# Check for
- Weak password requirements
- Missing brute-force protection
- Session fixation vulnerabilities
- Credential exposure in logs/URLs
```

## Transitive Dependency Analysis

### Identifying Transitive Vulnerabilities
```bash
# Check if package is directly used
grep -r "from PACKAGE" registry/
grep -r "import PACKAGE" registry/

# Find parent package
uv pip show PACKAGE | grep "Required-by"

# Check dependency tree
uv pip tree | grep -A 5 PACKAGE
```

### Resolution Strategies

| Scenario | Strategy |
|----------|----------|
| Parent package has update | Update parent package |
| Parent package no update available | Pin transitive dependency |
| Vulnerability in dev dependency | Update if possible, assess risk |
| False positive | Document with `# nosec` and justification |

### Documentation Template
```markdown
## CVE-YYYY-NNNNN Assessment

**Package**: vulnerable-package
**Severity**: HIGH/MEDIUM/LOW
**Type**: Direct / Transitive (via parent-package)

**Assessment**:
- Is the vulnerable code path used? Yes/No
- Is the input from untrusted sources? Yes/No

**Decision**: Fix / Accept Risk / Not Applicable

**Justification**: [Why this decision]
```
